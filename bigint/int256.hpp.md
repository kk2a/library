---
data:
  _extendedDependsOn:
  - icon: ':question:'
    path: type_traits/integral.hpp
    title: type_traits/integral.hpp
  - icon: ':question:'
    path: type_traits/io.hpp
    title: type_traits/io.hpp
  _extendedRequiredBy: []
  _extendedVerifiedWith: []
  _isVerificationFailed: false
  _pathExtension: hpp
  _verificationStatusIcon: ':warning:'
  attributes:
    links: []
  bundledCode: "#line 1 \"bigint/int256.hpp\"\n\n\n\n#include <cstdint>\n#include\
    \ <string>\n\n#line 1 \"type_traits/integral.hpp\"\n\n\n\n#include <type_traits>\n\
    \nnamespace kk2 {\n\n#ifndef _MSC_VER\n\ntemplate <typename T> using is_signed_int128\
    \ =\n    typename std::conditional<std::is_same<T, __int128_t>::value\n      \
    \                            or std::is_same<T, __int128>::value,\n          \
    \                    std::true_type,\n                              std::false_type>::type;\n\
    \ntemplate <typename T> using is_unsigned_int128 =\n    typename std::conditional<std::is_same<T,\
    \ __uint128_t>::value\n                                  or std::is_same<T, unsigned\
    \ __int128>::value,\n                              std::true_type,\n         \
    \                     std::false_type>::type;\n\ntemplate <typename T> using is_integral\
    \ =\n    typename std::conditional<std::is_integral<T>::value or is_signed_int128<T>::value\n\
    \                                  or is_unsigned_int128<T>::value,\n        \
    \                      std::true_type,\n                              std::false_type>::type;\n\
    \ntemplate <typename T> using is_signed =\n    typename std::conditional<std::is_signed<T>::value\
    \ or is_signed_int128<T>::value,\n                              std::true_type,\n\
    \                              std::false_type>::type;\n\ntemplate <typename T>\
    \ using is_unsigned =\n    typename std::conditional<std::is_unsigned<T>::value\
    \ or is_unsigned_int128<T>::value,\n                              std::true_type,\n\
    \                              std::false_type>::type;\n\ntemplate <typename T>\
    \ using make_unsigned_int128 =\n    typename std::conditional<std::is_same<T,\
    \ __int128_t>::value, __uint128_t, unsigned __int128>;\n\ntemplate <typename T>\
    \ using to_unsigned =\n    typename std::conditional<is_signed_int128<T>::value,\n\
    \                              make_unsigned_int128<T>,\n                    \
    \          typename std::conditional<std::is_signed<T>::value,\n             \
    \                                           std::make_unsigned<T>,\n         \
    \                                               std::common_type<T>>::type>::type;\n\
    \n#else\n\ntemplate <typename T> using is_integral = std::enable_if_t<std::is_integral<T>::value>;\n\
    template <typename T> using is_signed = std::enable_if_t<std::is_signed<T>::value>;\n\
    template <typename T> using is_unsigned = std::enable_if_t<std::is_unsigned<T>::value>;\n\
    template <typename T> using to_unsigned = std::make_unsigned<T>;\n\n#endif //\
    \ _MSC_VER\n\ntemplate <typename T> using is_integral_t = std::enable_if_t<is_integral<T>::value>;\n\
    template <typename T> using is_signed_t = std::enable_if_t<is_signed<T>::value>;\n\
    template <typename T> using is_unsigned_t = std::enable_if_t<is_unsigned<T>::value>;\n\
    \n} // namespace kk2\n\n\n#line 1 \"type_traits/io.hpp\"\n\n\n\n#include <istream>\n\
    #include <ostream>\n#line 7 \"type_traits/io.hpp\"\n\nnamespace kk2 {\n\nnamespace\
    \ type_traits {\n\nstruct istream_tag {};\nstruct ostream_tag {};\n\n} // namespace\
    \ type_traits\n\ntemplate <typename T> using is_standard_istream =\n    typename\
    \ std::conditional<std::is_same<T, std::istream>::value\n                    \
    \              || std::is_same<T, std::ifstream>::value,\n                   \
    \           std::true_type,\n                              std::false_type>::type;\n\
    template <typename T> using is_standard_ostream =\n    typename std::conditional<std::is_same<T,\
    \ std::ostream>::value\n                                  || std::is_same<T, std::ofstream>::value,\n\
    \                              std::true_type,\n                             \
    \ std::false_type>::type;\ntemplate <typename T> using is_user_defined_istream\
    \ = std::is_base_of<type_traits::istream_tag, T>;\ntemplate <typename T> using\
    \ is_user_defined_ostream = std::is_base_of<type_traits::ostream_tag, T>;\n\n\
    template <typename T> using is_istream =\n    typename std::conditional<is_standard_istream<T>::value\
    \ || is_user_defined_istream<T>::value,\n                              std::true_type,\n\
    \                              std::false_type>::type;\n\ntemplate <typename T>\
    \ using is_ostream =\n    typename std::conditional<is_standard_ostream<T>::value\
    \ || is_user_defined_ostream<T>::value,\n                              std::true_type,\n\
    \                              std::false_type>::type;\n\ntemplate <typename T>\
    \ using is_istream_t = std::enable_if_t<is_istream<T>::value>;\ntemplate <typename\
    \ T> using is_ostream_t = std::enable_if_t<is_ostream<T>::value>;\n\n} // namespace\
    \ kk2\n\n\n#line 9 \"bigint/int256.hpp\"\n\nnamespace kk2 {\n\nnamespace bigint\
    \ {\n\nstruct uint256 {\n    using u64 = uint64_t;\n    using u128 = __uint128_t;\n\
    \    using u256 = uint256;\n\n    constexpr uint256() { _v[0] = _v[1] = 0; }\n\
    \    template <class T, is_integral_t<T> * = nullptr> constexpr uint256(T x) {\n\
    \        _v[0] = x, _v[1] = 0;\n    }\n\n    constexpr uint256 &operator+=(const\
    \ uint256 &r) {\n        _v[1] += r._v[1];\n        bool a = _v[0] >> 127;\n \
    \       bool b = r._v[0] >> 127;\n        _v[0] = ((_v[0] << 1) >> 1) + ((r._v[0]\
    \ << 1) >> 1);\n        bool c = _v[0] >> 127;\n        if ((a and b) or (b and\
    \ c) or (c and a)) ++_v[1];\n        _v[0] = _v[0] ^ (u128(a) << 127) ^ (u128(b)\
    \ << 127);\n        return *this;\n    }\n\n  private:\n    u128 _v[2];\n};\n\n\
    } // namespace bigint\n\nusing u256 = bigint::uint256;\n\n} // namespace kk2\n\
    \n\n\n"
  code: "#ifndef KK2_BIGINT_INT256_HPP\n#define KK2_BIGINT_INT256_HPP 1\n\n#include\
    \ <cstdint>\n#include <string>\n\n#include \"../type_traits/integral.hpp\"\n#include\
    \ \"../type_traits/io.hpp\"\n\nnamespace kk2 {\n\nnamespace bigint {\n\nstruct\
    \ uint256 {\n    using u64 = uint64_t;\n    using u128 = __uint128_t;\n    using\
    \ u256 = uint256;\n\n    constexpr uint256() { _v[0] = _v[1] = 0; }\n    template\
    \ <class T, is_integral_t<T> * = nullptr> constexpr uint256(T x) {\n        _v[0]\
    \ = x, _v[1] = 0;\n    }\n\n    constexpr uint256 &operator+=(const uint256 &r)\
    \ {\n        _v[1] += r._v[1];\n        bool a = _v[0] >> 127;\n        bool b\
    \ = r._v[0] >> 127;\n        _v[0] = ((_v[0] << 1) >> 1) + ((r._v[0] << 1) >>\
    \ 1);\n        bool c = _v[0] >> 127;\n        if ((a and b) or (b and c) or (c\
    \ and a)) ++_v[1];\n        _v[0] = _v[0] ^ (u128(a) << 127) ^ (u128(b) << 127);\n\
    \        return *this;\n    }\n\n  private:\n    u128 _v[2];\n};\n\n} // namespace\
    \ bigint\n\nusing u256 = bigint::uint256;\n\n} // namespace kk2\n\n\n#endif //\
    \ KK2_BIGINT_INT256_HPP\n"
  dependsOn:
  - type_traits/integral.hpp
  - type_traits/io.hpp
  isVerificationFile: false
  path: bigint/int256.hpp
  requiredBy: []
  timestamp: '2025-10-08 11:21:40+09:00'
  verificationStatus: LIBRARY_NO_TESTS
  verifiedWith: []
documentation_of: bigint/int256.hpp
layout: document
redirect_from:
- /library/bigint/int256.hpp
- /library/bigint/int256.hpp.html
title: bigint/int256.hpp
---
